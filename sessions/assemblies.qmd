---
title: "Assembly and Co-assembly of Metagenomic Raw Reads"
date: 2023-10-10
license: "Apache 2.0"
author:
  - name: Germana Baldi
    orcid: 0000-0003-1719-5206
    email: germanab@ebi.ac.uk
    affiliation: 
      - name: EMBL-EBI
        url: www.ebi.ac.uk
  - name: Tanya Gurbich
    orcid: 0000-0002-7537-8871
    email: tgurbich@ebi.ac.uk
    affiliation: 
      - name: EMBL-EBI
        url: www.ebi.ac.uk
---
--------------------------------------------------

# Learning Objectives

In the following exercises you will learn how to perform a 
metagenomic assembly and to start some basic analysis of the output. Subsequently, 
we will demonstrate the application of co-assembly. We will shortly observe assembly 
graphs with `Bandage`, peek into assembly statistics with `assembly_stats`, and 
align contig files against the BLAST database.

::: {.callout-note}
The process of metagenomics assembly can take hours, if not days, to complete on a 
normal sample, as it often requires days of CPU time and 100s of GB of memory. In
this practical, we will only be investigating very simple example datasets. Thus, 
do not think that there is an issue with the assemblies.
:::

Once you have quality filtered your sequencing reads, you may want 
to perform *de novo* assembly in addition to, or as an
alternative to read-based analyses. The first step is to
assemble your sequences into contigs. There are many tools available for
this, such as MetaVelvet, metaSPAdes, IDBA-UD, MEGAHIT. We generally use
metaSPAdes, as in most cases it yields the best contig size statistics
(i.e. more continguous assembly) and has been shown to be able to
capture high degrees of community diversity (Vollmers, et al. PLOS One 2017). 
However, you should consider the pros and cons of different assemblers, 
which not only includes the accuracy of the assembly, but also their 
computational overhead. Compare these factors to what you have available. 
For example, very diverse samples with a lot of sequence data (e.g. samples 
from the soil) uses a lot of memory with SPAdes. In the following practicals 
we will demonstrate the use of **metaSPAdes** on a small short-read sample, 
**Flye** on a long-read sample, and **MEGAHIT** to perform co-assembly.

# Before we start...

Let’s first change to the working directory where we will be running all 
the analyses:

```bash
cd /home/training/Assembly/
```

You will find all inputs needed for assemblies in the `reads` folder. 

:::{.callout-note}
If anything goes wrong during the practical, you will find assembly backups 
for all steps in the respective ".bak" folders. 
:::

# Short-reads assemblies: metaSPAdes
For short reads, we will use SPAdes - St. Petersburg genome assembler 
(https://github.com/ablab/spades), a suite of assembling tools containing
different assembly pipelines. For metagenomic data, we will explore metaSPAdes.
metaSPAdes offers many options that fit your preferences differently,
mostly depending on the type of data you are willing to assemble.
To explore them, type `metaspades.py -h`. Bear in mind that options will 
differ when selecting different tools (e.g. spades.py) and they should be tuned
according to the input dataset and desired outcome.

:::{.callout-step .callout-tip}
The default metaSPAdes pipeline executes an error correction step on the 
input fastqs. To run metaspades without the error correction step, execute 
the following commands:

```bash
mkdir assembly_spades
metaspades.py -t 4 --only-assembler -m 10 -1 reads/oral_human_example_1_splitaa_kneaddata_paired_1.fastq -2 reads/oral_human_example_1_splitaa_kneaddata_paired_2.fastq -o spades_out
```
:::

:::{.callout-note}
The execution will take up to 20 minutes.
:::

Once the assembly has completed, you will see plenty of files, including
intermediate ones, in the `assembly_spades` folder. `contigs.fasta` and 
`scaffolds.fasta` are the ones you are usually interested into for 
downstream analyses (e.g. binning and MAG generation). We will focus on 
`contigs.fasta` for this session, which is the same you are going to use
in the coming practicals. Contigs in this file are ordered from the longest
to the shortest. You can already try to infer a strong taxonomic 
signal at this stage with a quick blastn alignment.

:::{.callout-step .callout-tip}
Take the first 100 lines of the sequence and perform a blast search
at NCBI (https://blast.ncbi.nlm.nih.gov/Blast.cgi, choose
Nucleotide:Nucleotide from the set of options). Leave all other options
as default on the search page. To select the first 100 lines of the assembly
perform the following:

```bash
head -n 101 assembly.bak/contigs.fasta
```

The resulting output is going to look similar to this:
![Blast-n](blast.png)
:::

:::{.callout-question .callout-tip}
Which species do you think this sequence may be coming from?
Does this make sense as a human oral bacteria? Are you surprised by this
result at all?  
:::

As mentioned in the theory talk, you might be interested in different 
types of statistics for your contigs file. `assembly_stats` is a tool that
produces two simple tables in JSON format with various measures, including
N10 to N50, GC content, longest contig and more. The first section 
corresponds to the scaffolds in the assembly, while the second corresponds 
to the contigs.

N50 is a measure to describe the quality of assembled genomes
that are fragmented in contigs of different length.  We can apply this
with some caution to metagenomes, where we can use it to crudely assess
the contig length that covers 50% of the total assembly.  Essentially
the longer the better, but this only makes sense when thinking about
alike metagenomes. Note, N10 is the minimum contig length to cover 10
percent of the metagenome. 

:::{.callout-step .callout-tip}

```bash
assembly_stats assembly.bak/scaffolds.fasta
```
:::

:::{.callout-question .callout-tip}
What is the length of longest and shortest contigs? 

What is the N50 of the assembly? Given that are input
sequences were ~150bp long paired-end sequences, what does this tell you
about the assembly?
:::

Another tool to keep in mind for metagenomic assemblies is QUAST,
which provides a deeper insight on assemblies statistics like indels
and misassemblies rate in a very short time.

# Long-reads assemblies: Flye

For long-reads, we will use Flye (https://github.com/fenderglass/Flye), 
which assembles single-molecule sequencing reads like PacBio and 
Oxford Nanopore Technologies (ONT) reads. As spades, Flye is a pipeline that 
takes care of assembly polishing. Similarly to assembly scaffolding, it tries 
to overcome long-reads base call error by comparing different reads that cover 
the same sequencing fragment. Flye's parameters are quickly described in the
help command (`flye -h`).

Flye supports metagenomic assemblies with the `--meta` flag.

:::{.callout-step .callout-tip}
```bash
flye --nano-raw reads/oral_human_example_1_splitaa_kneaddata_paired_1.fastq --out-dir flye_out --threads 4
```
:::

:::{.callout-note}
# Extra
Note that we are not using the `--meta` flag. If you have some spare time, 
try to execute the same command with this flag and output folder "`LR_meta_assembly`".
:::

:::{.callout-note}
Each execution will take around 5 minutes.
:::

Let's have a first look at how assembly graphs look like.
Bandage (a Bioinformatics Application for Navigating De novo
Assembly Graphs Easily) is a program that creates interactive
visualisations of assembly graphs. They can be useful for finding
sections of the graph, such as rRNA, or identify specific parts of a
genome. Note, you can install Bandage on your local system. With
Bandage, you can zoom and pan around the graph and search for sequences,
and much more.

Wnen looking at metaSPAdes output, it is usually recommended to 
launch Bandage on `assembly_graph.fastg`. However, our assembly is 
quite fragmented, so we will load `assembly_graph_after_simplification.gfa`.

We will use Bandage to compare the two assemblies we have generated.

:::{.callout-step .callout-tip}
```bash
Bandage
```

In the Bandage GUI perform the following

- Select File -> Load graph
- Navigate to Home/training/Data/Assembly -> assembly.bak and open `assembly_graph_after_simplification.gfa`

Once loaded, you need to draw the graph. To do so, under the “Graph
drawing” panel on the left side perform the following:

- Set Scope to `Entire graph`
- Click on `Draw graph`
:::

:::{.callout-question .callout-tip}
Can you find any large, complex parts of the metaSPAdes graph? 
If so, what do they look like?
:::

:::{.callout-question .callout-tip}
How does the Flye assembly differ from the one generated with metaSPAdes?
:::

:::{.callout-note}
# Extra
We launched Flye both with and without `--meta` on file `reads/ONT_example.fastq`.
This file actually comes from run ERR3775163, which can be browsed on ENA
(https://www.ebi.ac.uk/ena/browser/home). Have a look at sample metadata. Can 
you understand why, despite dealing with a metagenomic sample, the assembly graph
looks better for the execution without the `--meta` option?
:::

# Co-assemblies: MEGAHIT

:::{.callout-step .callout-tip}
In the following steps of this exercise, we will look at
performing co-assembly of multiple datasets.
In case you do not manage to finish these on time, the directory **coassembly** 
contains all the expected results.
:::

:::{.callout-step .callout-tip}
First, we need to make sure the output directories we are going to create do not already exist (MEGAHIT cannot overwrite existing directories). Run:

```bash
cd /home/training/Assembly/coassembly.bak
```
:::

:::{.callout-step .callout-tip}
Then, perform the coassemblies with MEGAHIT, as follows:

```bash
megahit -1 ../reads/oral_human_example_1_splitaa_kneaddata_paired_1.fastq -2 ../reads/oral_human_example_1_splitaa_kneaddata_paired_2.fastq -o  assembly1_new -t 4 --k-list 23,51,77 

megahit -1 ../reads/oral_human_example_1_splitaa_kneaddata_paired_1.fastq,../reads/oral_human_example_1_splitab_kneaddata_paired_1.fastq -2 ../reads/oral_human_example_1_splitaa_kneaddata_paired_2.fastq,../reads/oral_human_example_1_splitab_kneaddata_paired_2.fastq -o assembly2_new -t 4 --k-list 23,51,77 

megahit -1 ../reads/oral_human_example_1_splitaa_kneaddata_paired_1.fastq,../reads/oral_human_example_1_splitab_kneaddata_paired_1.fastq,../reads/oral_human_example_1_splitac_kneaddata_paired_1.fastq -2 ../reads/oral_human_example_1_splitaa_kneaddata_paired_2.fastq,../reads/oral_human_example_1_splitab_kneaddata_paired_2.fastq,../reads/oral_human_example_1_splitac_kneaddata_paired_2.fastq -o assembly3_new -t 4 --k-list 23,51,77
:::

You should now have three different assemblies generated from different 
subsamples of the same data.

:::{.callout-step .callout-tip}
Compare the results of contig files with `assembly_stats`. How do these 
assemblies differ to the one generated previously with metaSPAdes? 
Which one do you think is best?
:::

# ... And now?
If you have reached the end of the practical and have some spare time, 
look at the paragraphs labelled "Extra". They contain optional exercises for the 
curious student :)
