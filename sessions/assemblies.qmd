---
title: "Assemblies and Co-assemblies"
date: 2023-10-10
license: "Apache 2.0"
author:
  - name: Germana Baldi
    orcid: 0000-0003-1719-5206
    email: germanab@ebi.ac.uk
    affiliation: 
      - name: EMBL-EBI
        url: www.ebi.ac.uk
  - name: Tanya Gurbich
    orcid: 0000-0002-7537-8871
    email: tgurbich@ebi.ac.uk
    affiliation: 
      - name: EMBL-EBI
        url: www.ebi.ac.uk
---

Assembly and Co-assembly of Metagenomic Raw Reads
--------------------------------------------------

#Learning Objectives

In the following exercises you will learn how to perform a 
metagenomic assembly and to start some basic analysis of the output. Subsequently, 
we will demonstrate the application of co-assembly. 

::: {.callout-note}
The process of metagenomics assembly can take hours, if not days, to complete on a 
normal sample, as it often requires days of CPU time and 100s of GB of memory. In
this practical, we will only be investigating very simple example datasets. Thus, 
do not think that there is an issue with the assemblies.
:::

Once you have quality filtered your sequencing reads, you may want 
to perform *de novo* assembly in addition to, or as an
alternative to read-based analyses. The first step is to
assemble your sequences into contigs. There are many tools available for
this, such as MetaVelvet, metaSPAdes, IDBA-UD, MEGAHIT. We generally use
metaSPAdes, as in most cases it yields the best contig size statistics
(i.e. more continguous assembly) and has been shown to be able to
capture high degrees of community diversity (Vollmers, et al. PLOS One 2017). 
However, you should consider the pros and cons of different assemblers, 
which not only includes the accuracy of the assembly, but also their 
computational overhead. Compare these factors to what you have available. 
For example, very diverse samples with a lot of sequence data (e.g. samples 
from the soil) uses a lot of memory with SPAdes. In the following practicals 
we will demonstrate the use of **metaSPAdes** on a small short-read sample, 
**Flye** on a long-read sample, and **MEGAHIT** to perform co-assembly.

# Before we start...

Let’s first change to the working directory where we will be running all 
the analyses:

```bash
cd /home/training/Assembly/
```

You will find all inputs needed for assemblies in the `reads` folder. 

:::{.callout-note}
If anything goes wrong during the practical, you will find assembly backups 
for all steps in the respective ".bak" folders. 
:::

# Short-reads assemblies: metaSPAdes
For short reads, we will use SPAdes - St. Petersburg genome assembler 
(https://github.com/ablab/spades). Different pipelines are provided within
this suite. For metagenomic data, we will explore metaSPAdes.
metaSPAdes offers many options that fit your preferences differently,
mostly depending on the type of data you are willing to assemble.
To explore them, type `metaspades.py -h`. Bear in mind that options will 
differ when selecting different tools (e.g. spades.py).

:::{.callout-step .callout-tip}
To run metaspades without error correction, execute the following commands:
```bash
mkdir assembly_spades
metaspades.py -t 4 --only-assembler -m 10 -1 reads/oral_human_example_1_splitaa_kneaddata_paired_1.fastq -2 reads/oral_human_example_1_splitaa_kneaddata_paired_2.fastq -o spades_out
:::


:::{.callout-step .callout-tip}
For this, take the first 40 lines of the sequence and perform a blast search
at NCBI (https://blast.ncbi.nlm.nih.gov/Blast.cgi, choose
Nucleotide:Nucleotide from the set of options). Leave all other options
as default on the search page. To select the first 40 lines of the assembly
perform the following:

```bash
head -41 assembly.bak/contigs.fasta
```
:::

:::{.callout-question .callout-tip}
Which species do you think this sequence may be coming from?
Does this make sense as a human oral bacteria? Are you surprised by this
result at all?  
:::

:::{.callout-step .callout-tip}
Now let us consider some statistics about the entire assembly

```bash
assembly_stats assembly.bak/scaffolds.fasta
```
:::

:::{.callout-question .callout-tip}
What is the length of longest and shortest contigs? 

What is the N50 of the assembly? Given that are input
sequences were ~150bp long paired-end sequences, what does this tell you
about the assembly?
:::

N50 is a measure to describe the quality of assembled genomes
that are fragmented in contigs of different length.  We can apply this
with some caution to metagenomes, where we can use it to crudely assess
the contig length that covers 50% of the total assembly.  Essentially
the longer the better, but this only makes sense when thinking about
alike metagenomes. Note, N10 is the minimum contig length to cover 10
percent of the metagenome. N90 is the minimum contig length to cover 90
percent of the metagenome.

:::{.callout-step .callout-tip}
Bandage (a Bioinformatics Application for Navigating De novo
Assembly Graphs Easily), is a program that creates interactive
visualisations of assembly graphs. They can be useful for finding
sections of the graph, such as rRNA, or to try to find parts of a
genome. Note, you can install Bandage on your local system. With
Bandage, you can zoom and pan around the graph and search for sequences,
plus much more. The following guide allows you to look at the assembly
graph.  Normally, I would recommend looking at the ‘
assembly_graph.fastg, but our assembly is quite fragmented, so we will
load up the assembly_graph_after_simplification.gfa.   

At the terminal, type 

```bash
Bandage
```

In the Bandage GUI perform the following

- Select File -> Load graph
- Navigate to Home -> training -> Data -> Assembly -> files -> assembly.bak and open the file assembly_graph_after_simplification.gfa

Once loaded, you need to draw the graph. To do so, under the “Graph
drawing” panel on the left side perform the following:

- Set Scope to 'Entire graph'
- The click on Draw graph
:::

:::{.callout-question .callout-tip}
Can you find any large, complex parts of the graph? If so,
what do they look like.
:::

:::{.callout-step .callout-tip}
For the long-reads assembly we will use Flye:

```bash
flye --nano-raw reads/oral_human_example_1_splitaa_kneaddata_paired_1.fastq --out-dir flye_out --threads 4
```
:::

:::{.callout-question .callout-tip}
How do these assemblies differ to the one generated previously with metaSPAdes?
:::

:::{.callout-step .callout-tip}
In the following steps of this exercise, we will look at
performing co-assembly of multiple datasets. Each should take about 15-20 min. In case you do not manage to finish these on time, the directory **coassembly** contains all the expected results.
:::

:::{.callout-step .callout-tip}
First, we need to make sure the output directories we are going to create do not already exist (MEGAHIT cannot overwrite existing directories). Run:

```bash
cd /home/training/Assembly/coassembly.bak
```
:::

:::{.callout-step .callout-tip}
Then, perform the coassemblies with MEGAHIT, as follows:

```bash
megahit -1 ../reads/oral_human_example_1_splitaa_kneaddata_paired_1.fastq -2 ../reads/oral_human_example_1_splitaa_kneaddata_paired_2.fastq -o  assembly1_new -t 4 --k-list 23,51,77 

megahit -1 ../reads/oral_human_example_1_splitaa_kneaddata_paired_1.fastq,../reads/oral_human_example_1_splitab_kneaddata_paired_1.fastq -2 ../reads/oral_human_example_1_splitaa_kneaddata_paired_2.fastq,../reads/oral_human_example_1_splitab_kneaddata_paired_2.fastq -o assembly2_new -
